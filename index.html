<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>GPT-4: How do I stop coding?</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<link rel="stylesheet" href="css/custom.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown data-separator-vertical="^--$">
					<script type="text/template">
						<!-- .slide: data-background-image="img/intro.jpg" data-background-opacity="0.3"-->

						GPT-4<!-- .element: class="r-fit-text" -->

						### How do I stop coding?

						Maciej Małecki; Capgemini, Craftsmanship, 2023<!-- .element: class="cyan"-->

						---

						(Expectation management)<!-- .element: class="cyan"-->

						## Artifical intelligence:

						* How would AI change my work (live)?
						* When would that happen?
						* Is my workplace safe?

						---

						> Artificial intelligence (AI) is intelligence—perceiving, synthesizing, and inferring information—demonstrated by machines, as opposed to intelligence displayed by humans or by other animals. (Wikipedia)

						Born as science discipline in 1956 (John McCarthy).

						--

						![ANN](img/ann.excalidraw.png)

						Artificial neural networks (ANNs) are computing systems inspired by the biological neural networks that constitute animal brains. (Wikipedia)

						--

						<div class="r-hstack gap1">
							<img src="img/neocortex.png" alt="neocortex">
							<div>
								<h3>neocortex</h3>
								<ul>
									<li>6 layers</li>
									<li>4-5mm thick</li>
									<li>~16 billions neurons</li>
									<li>~100 trillion ($10^{14}$) synapses</li>
								</ul>
							</div>
						</div>

						--

						![neuron](img/640px-Blausen_0657_MultipolarNeuron.png)

						By BruceBlaus - Own work, CC BY 3.0, [here](https://commons.wikimedia.org/w/index.php?curid=28761830).
						--

						![AN](img/an.excalidraw.png)

						<div>
							\[y_k = \varphi(\sum_{j=0}^mw_{kj}x_j)\]
						</div>

						---

						## Example problem to be solved

						A simple image processing<!-- .element: class="cyan"-->

						--

						![Domain](img/domain.excalidraw.png)

						--

						![Output](img/domain-output.excalidraw.png)

						--

						````kotlin[|4-6|7-10|11-13|14-16]
						image {
							getInput().set(file("src/spritepad/tony kucanie 4 klatki.png"))
							getUseBuildDir().set(true)
							split {
								width = 32
								height = 32
								extend {
									newWidth = 48
									newHeight = 42
									fillColor = Color(0, 0, 0, 255)
									split {
										width = 24
										height = 21
										sprite {
											getOutput().set(file("sprites/tony-duck-left.bin"))
										}
									}
								}
							}
						}
						````

						---

						![GPT-4](img/gpt.png)

						---

						<!-- .slide: data-background-image="img/ChatGPT_logo.svg" data-background-opacity="0.3"-->
						# Domain

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						## (human input)

						![Hum](img/hum-ava.png)	 Implement generic image class in Kotlin. It should internally store rectangular matrix of pixels consisting of red, green, blue and alpha compounds.

						--

						## (AI answer)

						![GPT](img/gpt-ava.svg) In this Kotlin implementation, we'll create a generic Image class that stores a rectangular matrix of pixels. Each pixel will be represented by a Color class, which contains the red, green, blue, and alpha components.

						--

						![GPT](img/gpt-ava.svg) 

						```kotlin[]
						data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)

						class Image(private val width: Int, private val height: Int) {

							private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }

							operator fun get(x: Int, y: Int): Color {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								return pixels[y][x]
							}

							operator fun set(x: Int, y: Int, color: Color) {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								pixels[y][x] = color
							}

							fun getWidth(): Int = width

							fun getHeight(): Int = height
						}

						```

						--

						![GPT](img/gpt-ava.svg) Here, we create a Color data class to store the RGBA components of a pixel. The Image class constructor takes the width and height as parameters and creates an array of Color objects. The get and set operator functions provide access to the individual pixels, and the getWidth and getHeight functions return the dimensions of the image.

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 expose width and height as properties

						--

						![GPT](img/gpt-ava.svg) To expose width and height as properties in the Image class, you can use Kotlin's property syntax. Here's the modified version of the Image class with the width and height properties exposed:

						--

						```kotlin[3]
						data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)

						class Image(val width: Int, val height: Int) {

							private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }

							operator fun get(x: Int, y: Int): Color {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								return pixels[y][x]
							}

							operator fun set(x: Int, y: Int, color: Color) {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								pixels[y][x] = color
							}
						}

						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 add a method that will create new image out of the given image that will be a subset of that image specified by top, left, width and height parameters

						--

						![GPT](img/gpt-ava.svg) You can add a subImage method to the Image class to create a new image that is a subset of the given image. The method takes top, left, width, and height parameters to specify the rectangular region that should be extracted from the original image.

						--

						![GPT](img/gpt-ava.svg) Here's the updated Image class with the subImage method:

						```kotlin[19-31]
						data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)

						class Image(val width: Int, val height: Int) {

							private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }

							operator fun get(x: Int, y: Int): Color {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								return pixels[y][x]
							}

							operator fun set(x: Int, y: Int, color: Color) {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								pixels[y][x] = color
							}

							fun subImage(top: Int, left: Int, width: Int, height: Int): Image {
								require(top in 0 until this.height) { "Top coordinate out of bounds" }
								require(left in 0 until this.width) { "Left coordinate out of bounds" }
								require(top + height <= this.height) { "Height out of bounds" }
								require(left + width <= this.width) { "Width out of bounds" }

								val newImage = Image(width, height)
								for (y in 0 until height) {
									for (x in 0 until width) {
										newImage[x, y] = this[left + x, top + y]
									}
								}
								return newImage
							}
						}

						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 add a method that will create a new image that will be a copy of the image extended to the new width and height where new are is filled with given color

						--

						![GPT](img/gpt-ava.svg) You can add an extend method to the Image class to create a new image that is an extended copy of the original image. The method takes newWidth, newHeight, and a fillColor parameter to specify the dimensions of the new image and the color to fill the extended area.

						--

						![GPT](img/gpt-ava.svg) Here's the updated Image class with the extend method:

						```kotlin[]
						data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)

						class Image(val width: Int, val height: Int) {

							private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }

							operator fun get(x: Int, y: Int): Color {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								return pixels[y][x]
							}

							operator fun set(x: Int, y: Int, color: Color) {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								pixels[y][x] = color
							}

							fun extend(newWidth: Int, newHeight: Int, fillColor: Color = Color(0, 0, 0, 255)): Image {
								require(newWidth >= width) { "New width must be greater or equal to the current width" }
								require(newHeight >= height) { "New height must be greater or equal to the current height" }

								val newImage = Image(newWidth, newHeight)

								// Copy original image pixels
								for (y in 0 until height) {
									for (x in 0 until width) {
										newImage[x, y] = this[x, y]
									}
								}

								// Fill the extended area with the specified color
								for (y in 0 until newHeight) {
									for (x in 0 until newWidth) {
										if (x >= width || y >= height) {
											newImage[x, y] = fillColor
										}
									}
								}

								return newImage
							}
						}

						```

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	include subImage into the class as well

						--

						![GPT](img/gpt-ava.svg) I apologize for the confusion. To include the subImage method in the Image class, simply add it to the class definition as follows:

						```kotlin[]
						data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)

						class Image(val width: Int, val height: Int) {

							private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }

							operator fun get(x: Int, y: Int): Color {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								return pixels[y][x]
							}

							operator fun set(x: Int, y: Int, color: Color) {
								require(x in 0 until width) { "x coordinate out of bounds" }
								require(y in 0 until height) { "y coordinate out of bounds" }
								pixels[y][x] = color
							}

							fun subImage(top: Int, left: Int, width: Int, height: Int): Image {
								require(top in 0 until this.height) { "Top coordinate out of bounds" }
								require(left in 0 until this.width) { "Left coordinate out of bounds" }
								require(top + height <= this.height) { "Height out of bounds" }
								require(left + width <= this.width) { "Width out of bounds" }

								val newImage = Image(width, height)
								for (y in 0 until height) {
									for (x in 0 until width) {
										newImage[x, y] = this[left + x, top + y]
									}
								}
								return newImage
							}

							fun extend(newWidth: Int, newHeight: Int, fillColor: Color = Color(0, 0, 0, 255)): Image {
								require(newWidth >= width) { "New width must be greater or equal to the current width" }
								require(newHeight >= height) { "New height must be greater or equal to the current height" }

								val newImage = Image(newWidth, newHeight)

								// Copy original image pixels
								for (y in 0 until height) {
									for (x in 0 until width) {
										newImage[x, y] = this[x, y]
									}
								}

								// Fill the extended area with the specified color
								for (y in 0 until newHeight) {
									for (x in 0 until newWidth) {
										if (x >= width || y >= height) {
											newImage[x, y] = fillColor
										}
									}
								}

								return newImage
							}
						}

						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 Implement unit tests for class Image using Kotest

						--

						![GPT](img/gpt-ava.svg) To create unit tests for the Image class using the Kotest framework, you'll first need to add the Kotest dependencies to your project. If you're using Gradle, add the following dependencies to your build.gradle.kts file:

						```kotlin[]
						dependencies {
							testImplementation("io.kotest:kotest-framework-engine:4.6.3")
							testImplementation("io.kotest:kotest-assertions-core:4.6.3")
							testImplementation("io.kotest:kotest-runner-junit5:4.6.3")
						}
						```

						--

						![GPT](img/gpt-ava.svg) Now, create a test class for the Image class. In this example, we'll create a file named ImageTest.kt with the following content:

						```kotlin[]
						import io.kotest.core.spec.style.StringSpec
						import io.kotest.matchers.ints.shouldBeExactly
						import io.kotest.matchers.shouldBe

						class ImageTest : StringSpec({

							"Image dimensions should be initialized correctly" {
								val image = Image(100, 50)

								image.width shouldBeExactly 100
								image.height shouldBeExactly 50
							}

							"Setting and getting pixel colors should work correctly" {
								val image = Image(100, 50)
								val color = Color(100, 200, 150, 255)

								image[10, 20] = color
								image[10, 20] shouldBe color
							}

							"SubImage should return correct image region" {
								val image = Image(100, 50)

								// Fill the image with unique colors for demonstration purposes
								for (y in 0 until image.height) {
									for (x in 0 until image.width) {
										image[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
									}
								}

								val subImage = image.subImage(10, 20, 30, 15)

								subImage.width shouldBeExactly 30
								subImage.height shouldBeExactly 15

								for (y in 0 until subImage.height) {
									for (x in 0 until subImage.width) {
										subImage[x, y] shouldBe image[x + 20, y + 10]
									}
								}
							}

							"Extend should return correct extended image" {
								val image = Image(100, 50)

								// Fill the image with unique colors for demonstration purposes
								for (y in 0 until image.height) {
									for (x in 0 until image.width) {
										image[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
									}
								}

								val fillColor = Color(0, 0, 0, 255)
								val extendedImage = image.extend(150, 80, fillColor)

								extendedImage.width shouldBeExactly 150
								extendedImage.height shouldBeExactly 80

								for (y in 0 until extendedImage.height) {
									for (x in 0 until extendedImage.width) {
										if (x < image.width && y < image.height) {
											extendedImage[x, y] shouldBe image[x, y]
										} else {
											extendedImage[x, y] shouldBe fillColor
										}
									}
								}
							}
						})

						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 use behavior spec

						--

						![GPT](img/gpt-ava.svg) To use the BehaviorSpec style from Kotest, you can update your test class like this:

						```kotlin[]
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.ints.shouldBeExactly
						import io.kotest.matchers.shouldBe

						class ImageTest : BehaviorSpec({
							Given("An Image instance with dimensions 100x50") {
								val image = Image(100, 50)

								When("checking dimensions") {
									Then("the width should be 100 and the height should be 50") {
										image.width shouldBeExactly 100
										image.height shouldBeExactly 50
									}
								}

								When("setting and getting pixel colors") {
									val color = Color(100, 200, 150, 255)
									image[10, 20] = color

									Then("the color should be set and retrieved correctly") {
										image[10, 20] shouldBe color
									}
								}

								When("creating a subImage") {
									// Fill the image with unique colors for demonstration purposes
									for (y in 0 until image.height) {
										for (x in 0 until image.width) {
											image[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
										}
									}

									val subImage = image.subImage(10, 20, 30, 15)

									Then("the subImage should have the correct dimensions") {
										subImage.width shouldBeExactly 30
										subImage.height shouldBeExactly 15
									}

									Then("the subImage should contain the correct region from the original image") {
										for (y in 0 until subImage.height) {
											for (x in 0 until subImage.width) {
												subImage[x, y] shouldBe image[x + 20, y + 10]
											}
										}
									}
								}

								When("extending the image") {
									// Fill the image with unique colors for demonstration purposes
									for (y in 0 until image.height) {
										for (x in 0 until image.width) {
											image[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
										}
									}

									val fillColor = Color(0, 0, 0, 255)
									val extendedImage = image.extend(150, 80, fillColor)

									Then("the extended image should have the correct dimensions") {
										extendedImage.width shouldBeExactly 150
										extendedImage.height shouldBeExactly 80
									}

									Then("the extended image should contain the original image and the fill color in the extended area") {
										for (y in 0 until extendedImage.height) {
											for (x in 0 until extendedImage.width) {
												if (x < image.width && y < image.height) {
													extendedImage[x, y] shouldBe image[x, y]
												} else {
													extendedImage[x, y] shouldBe fillColor
												}
											}
										}
									}
								}
							}
						})

						```

						---

						<!-- .slide: data-background-image="img/ChatGPT_logo.svg" data-background-opacity="0.3"-->
						# Use cases

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 implement a function, that will produce a series of images of given width and height being a consensutive horizontal subimages of given image

						--

						![GPT](img/gpt-ava.svg) You can create a function called splitImageIntoSubimages that takes an input Image and the dimensions of the desired subimages. The function will then generate a series of horizontal subimages of the specified size. Here's the implementation of the function:

						```kotlin[]
						fun splitImageIntoSubimages(image: Image, subImageWidth: Int, subImageHeight: Int): List<Image> {
							require(subImageWidth > 0) { "Subimage width must be greater than 0" }
							require(subImageHeight > 0) { "Subimage height must be greater than 0" }
							require(subImageWidth <= image.width) { "Subimage width must be less than or equal to the image width" }
							require(subImageHeight <= image.height) { "Subimage height must be less than or equal to the image height" }
						
							val subImages = mutableListOf<Image>()
							var x = 0
						
							while (x + subImageWidth <= image.width) {
								subImages.add(image.subImage(0, x, subImageWidth, subImageHeight))
								x += subImageWidth
							}
						
							return subImages
						}
						```

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png)	 Write unit tests for this class using kotest and behavior spec

						```kotlin[]
						data class CutImageCommand(val file: File, val width: Int, val height: Int, val left: Int = 0, val top: Int = 0)
						class CutImageUseCase(private val readImagePort: ReadImagePort) {

						fun apply(command: CutImageCommand): Array<Image> {
							val sourceImage = readImagePort.read(command.file)

							require(command.width > 0) { "Subimage width must be greater than 0" }
							require(command.height > 0) { "Subimage height must be greater than 0" }
							require(command.width + command.left <= sourceImage.width) { "Subimage width must be less than or equal to the image width" }
							require(command.height + command.top  <= sourceImage.height) { "Subimage height must be less than or equal to the image height" }

							val subImages = mutableListOf<Image>()
							var x = command.left

							while (x + command.width <= sourceImage.width) {
							subImages.add(sourceImage.subImage(command.top, x, command.width, command.height))
							x += command.width
							}

							return subImages.toTypedArray()
						}
						}
						```

						--

						![GPT](img/gpt-ava.svg) First, let's create a simple ReadImagePort interface:

						```kotlin[]
						interface ReadImagePort {
							fun read(file: File): Image
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) Now we can write unit tests for the CutImageUseCase class using Kotest and the BehaviorSpec style:

						```kotlin[]
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.collections.shouldHaveSize
						import io.kotest.matchers.shouldBe
						import java.io.File

						class CutImageUseCaseTest : BehaviorSpec({
							Given("A CutImageUseCase with a ReadImagePort implementation") {
								val readImagePort = object : ReadImagePort {
									override fun read(file: File): Image {
										return Image(100, 50).apply {
											for (y in 0 until height) {
												for (x in 0 until width) {
													this[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
												}
											}
										}
									}
								}
								val cutImageUseCase = CutImageUseCase(readImagePort)

								When("a CutImageCommand with valid parameters is provided") {
									val command = CutImageCommand(File("dummy_file"), 20, 50)
									val subImages = cutImageUseCase.apply(command)

									Then("it should return an array of Image objects with the correct dimensions") {
										subImages shouldHaveSize 4
										subImages.forEach { subImage ->
											subImage.width shouldBe 20
											subImage.height shouldBe 50
										}
									}
								}

								When("a CutImageCommand with invalid parameters is provided") {
									Then("it should throw an exception") {
										val invalidCommand = CutImageCommand(File("dummy_file"), 0, 50)
										shouldThrow<IllegalArgumentException> {
											cutImageUseCase.apply(invalidCommand)
										}
									}
								}
							}
						})

						```
						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) how about testing content of the subimages?

						--

						![GPT](img/gpt-ava.svg) To test the content of the subimages, you can add another Then block inside the When block for the valid parameters case. Here's the updated test class with the added test:

						```kotlin[]
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.collections.shouldHaveSize
						import io.kotest.matchers.shouldBe
						import java.io.File

						class CutImageUseCaseTest : BehaviorSpec({
							Given("A CutImageUseCase with a ReadImagePort implementation") {
								val readImagePort = object : ReadImagePort {
									override fun read(file: File): Image {
										return Image(100, 50).apply {
											for (y in 0 until height) {
												for (x in 0 until width) {
													this[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
												}
											}
										}
									}
								}
								val cutImageUseCase = CutImageUseCase(readImagePort)

								When("a CutImageCommand with valid parameters is provided") {
									val command = CutImageCommand(File("dummy_file"), 20, 50)
									val subImages = cutImageUseCase.apply(command)

									Then("it should return an array of Image objects with the correct dimensions") {
										subImages shouldHaveSize 4
										subImages.forEach { subImage ->
											subImage.width shouldBe 20
											subImage.height shouldBe 50
										}
									}

									Then("the subimages should contain the correct region from the original image") {
										val originalImage = readImagePort.read(File("dummy_file"))

										subImages.forEachIndexed { index, subImage ->
											for (y in 0 until subImage.height) {
												for (x in 0 until subImage.width) {
													subImage[x, y] shouldBe originalImage[x + 20 * index, y]
												}
											}
										}
									}
								}

								When("a CutImageCommand with invalid parameters is provided") {
									Then("it should throw an exception") {
										val invalidCommand = CutImageCommand(File("dummy_file"), 0, 50)
										shouldThrow<IllegalArgumentException> {
											cutImageUseCase.apply(invalidCommand)
										}
									}
								}
							}
						})

						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) Implement function that will cut image into subimages by given width and height assuming that original width is a multiply of width, the same for height. It should go from left to right and then top to bottom. Result should be an array of images.

						--

						![GPT](img/gpt-ava.svg) You can create a function called cutImageIntoSubimages that takes an input Image and the dimensions of the desired subimages. The function will then generate a series of subimages of the specified size, going from left to right and top to bottom. Here's the implementation of the function:

						```kotlin[]
						fun cutImageIntoSubimages(image: Image, subImageWidth: Int, subImageHeight: Int): Array<Image> {
							require(subImageWidth > 0) { "Subimage width must be greater than 0" }
							require(subImageHeight > 0) { "Subimage height must be greater than 0" }
							require(image.width % subImageWidth == 0) { "Image width must be a multiple of subimage width" }
							require(image.height % subImageHeight == 0) { "Image height must be a multiple of subimage height" }
						
							val numRows = image.height / subImageHeight
							val numCols = image.width / subImageWidth
							val subImages = mutableListOf<Image>()
						
							for (row in 0 until numRows) {
								for (col in 0 until numCols) {
									val left = col * subImageWidth
									val top = row * subImageHeight
									subImages.add(image.subImage(top, left, subImageWidth, subImageHeight))
								}
							}
						
							return subImages.toTypedArray()
						}
						```						

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) implement unit tests for this function in kotest

						--

						![GPT](img/gpt-ava.svg) Here's a test class for the `cutImageIntoSubimages` function using Kotest and the `BehaviorSpec` style:

						```kotlin
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.collections.shouldHaveSize
						import io.kotest.matchers.shouldBe
						
						class CutImageIntoSubimagesTest : BehaviorSpec({
							Given("An Image instance with dimensions 100x50") {
								val image = Image(100, 50).apply {
									for (y in 0 until height) {
										for (x in 0 until width) {
											this[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
										}
									}
								}
						
								When("cutting the image into subimages with dimensions 20x25") {
									val subImages = cutImageIntoSubimages(image, 20, 25)
						
									Then("it should return an array of Image objects with the correct dimensions") {
										subImages shouldHaveSize 10
										subImages.forEach { subImage ->
											subImage.width shouldBe 20
											subImage.height shouldBe 25
										}
									}
						
									Then("the subimages should contain the correct region from the original image") {
										for (i in subImages.indices) {
											val subImage = subImages[i]
											val offsetX = (i % 5) * 20
											val offsetY = (i / 5) * 25
						
											for (y in 0 until subImage.height) {
												for (x in 0 until subImage.width) {
													subImage[x, y] shouldBe image[x + offsetX, y + offsetY]
												}
											}
										}
									}
								}
						
								When("cutting the image into subimages with invalid dimensions") {
									Then("it should throw an exception") {
										shouldThrow<IllegalArgumentException> {
											cutImageIntoSubimages(image, 0, 50)
										}
									}
								}
							}
						})
						```
						
						This test class includes test cases for the `cutImageIntoSubimages` function with valid and invalid subimage dimensions, as well as a test case for checking the content of the subimages to ensure they contain the correct region from the original image.

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) write unit tests in kotest for this class:

						```kotlin
						package com.github.c64lib.rbt.processors.image.usecase
						
						import com.github.c64lib.rbt.processors.image.domain.Image
						
						data class CutImageCommand(val image: Image, val subImageWidth: Int, val subImageHeight: Int)
						class CutImageUseCase {
						  fun apply(command: CutImageCommand): Array<Image> {
							require(command.subImageWidth > 0) { "Subimage width must be greater than 0" }
							require(command.subImageHeight > 0) { "Subimage height must be greater than 0" }
							require(command.image.width % command.subImageWidth == 0) { "Image width must be a multiple of subimage width" }
							require(command.image.height % command.subImageHeight == 0) { "Image height must be a multiple of subimage height" }
						
							val numRows = command.image.height / command.subImageHeight
							val numCols = command.image.width / command.subImageWidth
							val subImages = mutableListOf<Image>()
						
							for (row in 0 until numRows) {
							  for (col in 0 until numCols) {
								val left = col * command.subImageWidth
								val top = row * command.subImageHeight
								subImages.add(command.image.subImage(top, left, command.subImageWidth, command.subImageHeight))
							  }
							}
						
							return subImages.toTypedArray()
						  }
						}
						```

						--

						![GPT](img/gpt-ava.svg) Here's a test class for the `CutImageUseCase` using Kotest and the `BehaviorSpec` style:

						```kotlin
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.collections.shouldHaveSize
						import io.kotest.matchers.shouldBe
						
						class CutImageUseCaseTest : BehaviorSpec({
							Given("A CutImageUseCase instance") {
								val cutImageUseCase = CutImageUseCase()
						
								And("An Image instance with dimensions 100x50") {
									val image = Image(100, 50).apply {
										for (y in 0 until height) {
											for (x in 0 until width) {
												this[x, y] = Color(x % 256, y % 256, (x + y) % 256, 255)
											}
										}
									}
						
									When("a CutImageCommand with valid parameters is provided") {
										val command = CutImageCommand(image, 20, 25)
										val subImages = cutImageUseCase.apply(command)
						
										Then("it should return an array of Image objects with the correct dimensions") {
											subImages shouldHaveSize 10
											subImages.forEach { subImage ->
												subImage.width shouldBe 20
												subImage.height shouldBe 25
											}
										}
						
										Then("the subimages should contain the correct region from the original image") {
											for (i in subImages.indices) {
												val subImage = subImages[i]
												val offsetX = (i % 5) * 20
												val offsetY = (i / 5) * 25
						
												for (y in 0 until subImage.height) {
													for (x in 0 until subImage.width) {
														subImage[x, y] shouldBe image[x + offsetX, y + offsetY]
													}
												}
											}
										}
									}
						
									When("a CutImageCommand with invalid parameters is provided") {
										Then("it should throw an exception") {
											val invalidCommand = CutImageCommand(image, 0, 50)
											shouldThrow<IllegalArgumentException> {
												cutImageUseCase.apply(invalidCommand)
											}
										}
									}
								}
							}
						})
						```
						
						This test class includes test cases for the `CutImageUseCase` with valid and invalid `CutImageCommand` parameters, as well as a test case for checking the content of the subimages to ensure they contain the correct region from the original image.

						---

						<!-- .slide: data-background-image="img/ChatGPT_logo.svg" data-background-opacity="0.3"-->
						# Adapters (1)

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) Given the following interface: 
						
						```kotlin
						interface ReadImagePort {
							fun read(file: File): Image
						  }
						```
						  
						implement in Kotlin an adapter (implementation) that parses PNG file into the Image structure.
						  
						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->
						![Hum](img/hum-ava.png) Image is declared as follows:
						
						```kotlin[]
						  data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)
						  
						  class Image(val width: Int, val height: Int) {
						  
							private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }
						  
							operator fun get(x: Int, y: Int): Color {
							  require(x in 0 until width) { "x coordinate out of bounds" }
							  require(y in 0 until height) { "y coordinate out of bounds" }
							  return pixels[y][x]
							}
						  
							operator fun set(x: Int, y: Int, color: Color) {
							  require(x in 0 until width) { "x coordinate out of bounds" }
							  require(y in 0 until height) { "y coordinate out of bounds" }
							  pixels[y][x] = color
							}
						  
							fun subImage(top: Int, left: Int, width: Int, height: Int): Image {
							  require(top in 0 until this.height) { "Top coordinate out of bounds" }
							  require(left in 0 until this.width) { "Left coordinate out of bounds" }
							  require(top + height <= this.height) { "Height out of bounds" }
							  require(left + width <= this.width) { "Width out of bounds" }
						  
							  val newImage = Image(width, height)
							  for (y in 0 until height) {
								for (x in 0 until width) {
								  newImage[x, y] = this[left + x, top + y]
								}
							  }
							  return newImage
							}
						  
							fun extend(newWidth: Int, newHeight: Int, fillColor: Color = Color(0, 0, 0, 255)): Image {
							  require(newWidth >= width) { "New width must be greater or equal to the current width" }
							  require(newHeight >= height) { "New height must be greater or equal to the current height" }
						  
							  val newImage = Image(newWidth, newHeight)
						  
							  // Copy original image pixels
							  for (y in 0 until height) {
								for (x in 0 until width) {
								  newImage[x, y] = this[x, y]
								}
							  }
						  
							  // Fill the extended area with the specified color
							  for (y in 0 until newHeight) {
								for (x in 0 until newWidth) {
								  if (x >= width || y >= height) {
									newImage[x, y] = fillColor
								  }
								}
							  }
						  
							  return newImage
							}
						  }
						```

						--

						![GPT](img/gpt-ava.svg) To implement an adapter that parses PNG files into the Image structure, you can use a library like `java.awt.image.BufferedImage` to read the PNG file and then create an Image from it. Here's the implementation:

						1. First, add the required dependencies to your `build.gradle.kts` or `build.gradle` file:
						
						```kotlin
						dependencies {
							implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
							implementation("org.jetbrains.kotlinx:kotlinx-io-jvm:0.1.16")
						}
						```
						--
						![GPT](img/gpt-ava.svg) 
						2. Create the `PngImageReader` class that implements `ReadImagePort`:
						
						```kotlin
						import java.awt.image.BufferedImage
						import java.io.File
						import javax.imageio.ImageIO
						
						class PngImageReader : ReadImagePort {
							override fun read(file: File): Image {
								val bufferedImage: BufferedImage = ImageIO.read(file)
								val width = bufferedImage.width
								val height = bufferedImage.height
								val image = Image(width, height)
						
								for (y in 0 until height) {
									for (x in 0 until width) {
										val argb = bufferedImage.getRGB(x, y)
										val alpha = (argb shr 24) and 0xff
										val red = (argb shr 16) and 0xff
										val green = (argb shr 8) and 0xff
										val blue = argb and 0xff
										val color = Color(red, green, blue, alpha)
										image[x, y] = color
									}
								}
						
								return image
							}
						}
						```
						
						--
						![GPT](img/gpt-ava.svg) This class uses the `javax.imageio.ImageIO` class to read the PNG file into a `BufferedImage` object. It then iterates over the pixels, extracts the color components, creates a `Color` object, and sets the corresponding pixel in the `Image` object.
						
						Now you can use the `PngImageReader` class to read PNG files into the `Image` structure:
						
						```kotlin
						fun main() {
							val file = File("path/to/your/png/file.png")
							val imageReader: ReadImagePort = PngImageReader()
							val image = imageReader.read(file)
						
							// Use the Image object as needed
							println("Image width: ${image.width}, height: ${image.height}")
						}
						```
						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) will that run on headless system like linux server without XServer installed?

						--

						![GPT](img/gpt-ava.svg) My apologies, I didn't take into account the potential headless environment. In that case, you can use the `TwelveMonkeys` library for parsing PNG images, which does not require an XServer. Here's how to modify the implementation:

						1. Add the required dependencies to your `build.gradle.kts` or `build.gradle` file:
						
						```kotlin
						dependencies {
							implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
							implementation("org.jetbrains.kotlinx:kotlinx-io-jvm:0.1.16")
							implementation("com.twelvemonkeys.imageio:imageio-core:3.7.0")
							implementation("com.twelvemonkeys.imageio:imageio-png:3.7.0")
						}
						```

						--

						![GPT](img/gpt-ava.svg)
						
						2. Modify the `PngImageReader` class to use the `TwelveMonkeys` library:
						
						```kotlin
						import com.twelvemonkeys.imageio.plugins.png.PNGImageReader
						import com.twelvemonkeys.imageio.plugins.png.PNGImageReaderSpi
						import java.awt.image.BufferedImage
						import java.io.File
						import java.io.FileInputStream
						import javax.imageio.stream.FileImageInputStream
						
						class PngImageReader : ReadImagePort {
							override fun read(file: File): Image {
								val inputStream = FileInputStream(file)
								val imageInputStream = FileImageInputStream(inputStream)
						
								val imageReader = PNGImageReader(PNGImageReaderSpi())
								imageReader.setInput(imageInputStream)
								val bufferedImage: BufferedImage = imageReader.read(0)
						
								val width = bufferedImage.width
								val height = bufferedImage.height
								val image = Image(width, height)
						
								for (y in 0 until height) {
									for (x in 0 until width) {
										val argb = bufferedImage.getRGB(x, y)
										val alpha = (argb shr 24) and 0xff
										val red = (argb shr 16) and 0xff
										val green = (argb shr 8) and 0xff
										val blue = argb and 0xff
										val color = Color(red, green, blue, alpha)
										image[x, y] = color
									}
								}
						
								return image
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg)	This implementation uses the `TwelveMonkeys` library to read the PNG file and should work without issues in a headless environment. The rest of the implementation remains the same.

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) How about pngj library from leonbloy?

						--

						![GPT](img/gpt-ava.svg) Certainly! The `pngj` library by leonbloy is a great option for parsing PNG files in a headless environment. Here's how to modify the implementation using the `pngj` library:

						1. Add the required dependency to your `build.gradle.kts` or `build.gradle` file:
						
						```kotlin
						dependencies {
							implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
							implementation("ar.com.hjg:pngj:2.1.0")
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) 2. Modify the `PngImageReader` class to use the `pngj` library:
						
						```kotlin
						import ar.com.hjg.pngj.ImageInfo
						import ar.com.hjg.pngj.PngReader
						import java.io.File
						
						class PngImageReader : ReadImagePort {
							override fun read(file: File): Image {
								val pngReader = PngReader(file)
								val imageInfo: ImageInfo = pngReader.imgInfo
								val width = imageInfo.cols
								val height = imageInfo.rows
								val image = Image(width, height)
						
								for (y in 0 until height) {
									val row = pngReader.readRow(y)
									for (x in 0 until width) {
										val r = row.getR(x)
										val g = row.getG(x)
										val b = row.getB(x)
										val a = if (imageInfo.channels == 4) row.getA(x) else 255
										val color = Color(r, g, b, a)
										image[x, y] = color
									}
								}
								pngReader.end()
						
								return image
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) This implementation uses the `pngj` library to read the PNG file and should work without issues in a headless environment. The rest of the implementation remains the same.
						
						Now you can use the `PngImageReader` class to read PNG files into the `Image` structure:
						
						```kotlin
						fun main() {
							val file = File("path/to/your/png/file.png")
							val imageReader: ReadImagePort = PngImageReader()
							val image = imageReader.read(file)
						
							// Use the Image object as needed
							println("Image width: ${image.width}, height: ${image.height}")
						}
						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) rename class to ReadPngImagePort

						--

						![GPT](img/gpt-ava.svg) Sure, I'll rename the class to `ReadPngImagePort`. Here's the updated implementation using the `pngj` library:

						```kotlin
						import ar.com.hjg.pngj.ImageInfo
						import ar.com.hjg.pngj.PngReader
						import java.io.File
						
						class ReadPngImagePort : ReadImagePort {
							override fun read(file: File): Image {
								val pngReader = PngReader(file)
								val imageInfo: ImageInfo = pngReader.imgInfo
								val width = imageInfo.cols
								val height = imageInfo.rows
								val image = Image(width, height)
						
								for (y in 0 until height) {
									val row = pngReader.readRow(y)
									for (x in 0 until width) {
										val r = row.getR(x)
										val g = row.getG(x)
										val b = row.getB(x)
										val a = if (imageInfo.channels == 4) row.getA(x) else 255
										val color = Color(r, g, b, a)
										image[x, y] = color
									}
								}
								pngReader.end()
						
								return image
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) Now you can use the `ReadPngImagePort` class to read PNG files into the `Image` structure:
						
						```kotlin
						fun main() {
							val file = File("path/to/your/png/file.png")
							val imageReader: ReadImagePort = ReadPngImagePort()
							val image = imageReader.read(file)
						
							// Use the Image object as needed
							println("Image width: ${image.width}, height: ${image.height}")
						}
						```

						--

						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) the row does not have getR and so on methods

						--

						![GPT](img/gpt-ava.svg) Apologies for the oversight. You're correct that the `ImageLine` class, which represents a row in the `pngj` library, does not have `getR`, `getG`, `getB`, and `getA` methods. Instead, you can use the `getElem` method to access the pixel values. Here's the corrected implementation of the `ReadPngImagePort` class:

						```kotlin
						import ar.com.hjg.pngj.ImageInfo
						import ar.com.hjg.pngj.PngReader
						import java.io.File
						
						class ReadPngImagePort : ReadImagePort {
							override fun read(file: File): Image {
								val pngReader = PngReader(file)
								val imageInfo: ImageInfo = pngReader.imgInfo
								val width = imageInfo.cols
								val height = imageInfo.rows
								val channels = imageInfo.channels
								val image = Image(width, height)
						
								for (y in 0 until height) {
									val row = pngReader.readRow(y)
									for (x in 0 until width) {
										val baseIndex = x * channels
										val r = row.getElem(baseIndex)
										val g = row.getElem(baseIndex + 1)
										val b = row.getElem(baseIndex + 2)
										val a = if (channels == 4) row.getElem(baseIndex + 3) else 255
										val color = Color(r, g, b, a)
										image[x, y] = color
									}
								}
								pngReader.end()
						
								return image
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) Now you can use the `ReadPngImagePort` class to read PNG files into the `Image` structure:
						
						```kotlin
						fun main() {
							val file = File("path/to/your/png/file.png")
							val imageReader: ReadImagePort = ReadPngImagePort()
							val image = imageReader.read(file)
						
							// Use the Image object as needed
							println("Image width: ${image.width}, height: ${image.height}")
						}
						```

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) no it does not work neither. Doc says that IImageLine should be casted to more concrete classes					
						
						--

						![GPT](img/gpt-ava.svg) Apologies for the confusion. You're right, the `IImageLine` returned by `readRow` should be cast to a more concrete class, such as `ImageLineInt` or `ImageLineByte`, depending on the `imgInfo.bitDepth` value. Here's the corrected implementation:

						```kotlin
						import ar.com.hjg.pngj.ImageInfo
						import ar.com.hjg.pngj.ImageLineByte
						import ar.com.hjg.pngj.ImageLineHelper
						import ar.com.hjg.pngj.ImageLineInt
						import ar.com.hjg.pngj.PngReader
						import java.io.File
						
						class ReadPngImagePort : ReadImagePort {
							override fun read(file: File): Image {
								val pngReader = PngReader(file)
								val imageInfo: ImageInfo = pngReader.imgInfo
								val width = imageInfo.cols
								val height = imageInfo.rows
								val channels = imageInfo.channels
								val image = Image(width, height)
						
								for (y in 0 until height) {
									val row = pngReader.readRow(y)
									for (x in 0 until width) {
										val color = when (row) {
											is ImageLineInt -> {
												val scanline = row.scanline
												val r = ImageLineHelper.getRgba8(scanline, x)
												val g = ImageLineHelper.getRgag8(scanline, x)
												val b = ImageLineHelper.getRgab8(scanline, x)
												val a = if (channels == 4) ImageLineHelper.getRgbaA8(scanline, x) else 255
												Color(r, g, b, a)
											}
											is ImageLineByte -> {
												val scanline = row.scanline
												val r = ImageLineHelper.getRgba8(scanline, x)
												val g = ImageLineHelper.getRgag8(scanline, x)
												val b = ImageLineHelper.getRgab8(scanline, x)
												val a = if (channels == 4) ImageLineHelper.getRgbaA8(scanline, x) else 255
												Color(r, g, b, a)
											}
											else -> throw IllegalStateException("Unsupported row type: ${row.javaClass}")
										}
										image[x, y] = color
									}
								}
								pngReader.end()
						
								return image
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) This implementation uses the `ImageLineInt` and `ImageLineByte` classes to handle different types of image rows and utilizes the `ImageLineHelper` class to access pixel values. The rest of the implementation remains the same.
						
						Now you can use the `ReadPngImagePort` class to read PNG files into the `Image` structure:
						
						```kotlin
						fun main() {
							val file = File("path/to/your/png/file.png")
							val imageReader: ReadImagePort = ReadPngImagePort()
							val image = imageReader.read(file)
						
							// Use the Image object as needed
							println("Image width: ${image.width}, height: ${image.height}")
						}
						```

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) ImageLineHelper.getRgba8 does not exist					
						
						--

						![GPT](img/gpt-ava.svg) Apologies once again for the confusion. You are correct that the `ImageLineHelper` methods I previously mentioned do not exist. Instead, you can use the `getPixel` method in combination with `getElem` to access pixel values. Here's the corrected implementation:

						```kotlin
						import ar.com.hjg.pngj.ImageInfo
						import ar.com.hjg.pngj.ImageLineByte
						import ar.com.hjg.pngj.ImageLineInt
						import ar.com.hjg.pngj.PngReader
						import java.io.File
						
						class ReadPngImagePort : ReadImagePort {
							override fun read(file: File): Image {
								val pngReader = PngReader(file)
								val imageInfo: ImageInfo = pngReader.imgInfo
								val width = imageInfo.cols
								val height = imageInfo.rows
								val channels = imageInfo.channels
								val image = Image(width, height)
						
								for (y in 0 until height) {
									val row = pngReader.readRow(y)
									for (x in 0 until width) {
										val color = when (row) {
											is ImageLineInt -> {
												val scanline = row.scanline
												val pixel = row.getPixel(x)
												val r = pixel[0]
												val g = pixel[1]
												val b = pixel[2]
												val a = if (channels == 4) pixel[3] else 255
												Color(r, g, b, a)
											}
											is ImageLineByte -> {
												val scanline = row.scanline
												val pixel = row.getPixel(x)
												val r = pixel[0].toInt() and 0xFF
												val g = pixel[1].toInt() and 0xFF
												val b = pixel[2].toInt() and 0xFF
												val a = if (channels == 4) pixel[3].toInt() and 0xFF else 255
												Color(r, g, b, a)
											}
											else -> throw IllegalStateException("Unsupported row type: ${row.javaClass}")
										}
										image[x, y] = color
									}
								}
								pngReader.end()
						
								return image
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) This implementation uses the `ImageLineInt` and `ImageLineByte` classes to handle different types of image rows and utilizes the `getPixel` method in combination with `getElem` to access pixel values. The rest of the implementation remains the same.
						
						Now you can use the `ReadPngImagePort` class to read PNG files into the `Image` structure:
						
						```kotlin
						fun main() {
							val file = File("path/to/your/png/file.png")
							val imageReader: ReadImagePort = ReadPngImagePort()
							val image = imageReader.read(file)
						
							// Use the Image object as needed
							println("Image width: ${image.width}, height: ${image.height}")
						}
						```

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) [at this moment I gave up and fixed that code manually]				

						---

						<!-- .slide: data-background-image="img/ChatGPT_logo.svg" data-background-opacity="0.3"-->
						# Adapters (2)
			
						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) Assuming following code: 

						```kotlin
						package com.github.c64lib.rbt.processors.image.domain
						
						data class Color(val red: Int, val green: Int, val blue: Int, val alpha: Int)
						
						class Image(val width: Int, val height: Int) {
						
						  private val pixels = Array(height) { Array(width) { Color(0, 0, 0, 255) } }
						
						  operator fun get(x: Int, y: Int): Color {
							require(x in 0 until width) { "x coordinate out of bounds" }
							require(y in 0 until height) { "y coordinate out of bounds" }
							return pixels[y][x]
						  }
						
						  operator fun set(x: Int, y: Int, color: Color) {
							require(x in 0 until width) { "x coordinate out of bounds" }
							require(y in 0 until height) { "y coordinate out of bounds" }
							pixels[y][x] = color
						  }
						
						  fun subImage(top: Int, left: Int, width: Int, height: Int): Image {
							require(top in 0 until this.height) { "Top coordinate out of bounds" }
							require(left in 0 until this.width) { "Left coordinate out of bounds" }
							require(top + height <= this.height) { "Height out of bounds" }
							require(left + width <= this.width) { "Width out of bounds" }
						
							val newImage = Image(width, height)
							for (y in 0 until height) {
							  for (x in 0 until width) {
								newImage[x, y] = this[left + x, top + y]
							  }
							}
							return newImage
						  }
						
						  fun extend(newWidth: Int, newHeight: Int, fillColor: Color = Color(0, 0, 0, 255)): Image {
							require(newWidth >= width) { "New width must be greater or equal to the current width" }
							require(newHeight >= height) { "New height must be greater or equal to the current height" }
						
							val newImage = Image(newWidth, newHeight)
						
							// Copy original image pixels
							for (y in 0 until height) {
							  for (x in 0 until width) {
								newImage[x, y] = this[x, y]
							  }
							}
						
							// Fill the extended area with the specified color
							for (y in 0 until newHeight) {
							  for (x in 0 until newWidth) {
								if (x >= width || y >= height) {
								  newImage[x, y] = fillColor
								}
							  }
							}
						
							return newImage
						  }
						
						  fun dump() {
							for (y in 0 until height) {
							  for (x in 0 until width) {
								print(
									if (pixels[y][x] == Color(0, 0, 0, 255)) {
									  "."
									} else {
									  "#"
									},
								)
							  }
							  println()
							}
						  }
						}
						```
												
						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) 	implement the following port:
						
						```kotlin
						interface WriteSpritePort {
						  fun write(image: Image, toFile: File)
						}
						```
						
						that will write an image to the binary file containing Commodore 64 sprite shape definition. Assume this is an hires sprite, Color(0,0,0,255) is for transparent pixel and any other for set pixel					
						
						--

						![GPT](img/gpt-ava.svg) To implement the `WriteSpritePort` interface, you need to create a class that writes an image to a binary file containing the Commodore 64 sprite shape definition. In this case, the sprite is a hires sprite, where Color(0, 0, 0, 255) represents a transparent pixel, and any other color represents a set pixel.

						--

						![GPT](img/gpt-ava.svg) Here is a possible implementation of the `WriteSpritePort` interface:
						
						```kotlin
						import com.github.c64lib.rbt.processors.image.domain.Color
						import com.github.c64lib.rbt.processors.image.domain.Image
						import java.io.File
						import java.io.FileOutputStream
						
						class C64SpriteWriter : WriteSpritePort {
							override fun write(image: Image, toFile: File) {
								require(image.width == 24) { "Sprite width must be 24 pixels for Commodore 64 hires sprites" }
								require(image.height == 21) { "Sprite height must be 21 pixels for Commodore 64 hires sprites" }
						
								val spriteData = ByteArray(63)
						
								for (y in 0 until 21) {
									for (x in 0 until 24 step 8) {
										val byte = ((if (image[x, y] != Color(0, 0, 0, 255)) 1 else 0) shl 7) or
												   ((if (image[x + 1, y] != Color(0, 0, 0, 255)) 1 else 0) shl 6) or
												   ((if (image[x + 2, y] != Color(0, 0, 0, 255)) 1 else 0) shl 5) or
												   ((if (image[x + 3, y] != Color(0, 0, 0, 255)) 1 else 0) shl 4) or
												   ((if (image[x + 4, y] != Color(0, 0, 0, 255)) 1 else 0) shl 3) or
												   ((if (image[x + 5, y] != Color(0, 0, 0, 255)) 1 else 0) shl 2) or
												   ((if (image[x + 6, y] != Color(0, 0, 0, 255)) 1 else 0) shl 1) or
												   (if (image[x + 7, y] != Color(0, 0, 0, 255)) 1 else 0)
						
										spriteData[y * 3 + x / 8] = byte.toByte()
									}
								}
						
								FileOutputStream(toFile).use { it.write(spriteData) }
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) In this implementation, the `C64SpriteWriter` class writes the image data to a file in the format of a Commodore 64 hires sprite. It converts the image pixels into a byte array, where each byte represents 8 pixels in a row, and the bits in the byte represent the state of the pixels (transparent or set). The byte array is then written to the specified file using

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) improve the code so that 1) color checking is extracted to a separate private method 2) resulting size is always 64 bytes so that add a zero byte at the end.				
						
						--

						![GPT](img/gpt-ava.svg) To improve the code as per your request, you can create a separate private method for color checking, and ensure that the resulting size is always 64 bytes by adding a zero byte at the end. Here's the modified implementation:
					
						```kotlin
						import com.github.c64lib.rbt.processors.image.domain.Color
						import com.github.c64lib.rbt.processors.image.domain.Image
						import java.io.File
						import java.io.FileOutputStream
						
						class C64SpriteWriter : WriteSpritePort {
							override fun write(image: Image, toFile: File) {
								require(image.width == 24) { "Sprite width must be 24 pixels for Commodore 64 hires sprites" }
								require(image.height == 21) { "Sprite height must be 21 pixels for Commodore 64 hires sprites" }
						
								val spriteData = ByteArray(64)
						
								for (y in 0 until 21) {
									for (x in 0 until 24 step 8) {
										val byte = (pixelValue(image[x, y]) shl 7) or
												   (pixelValue(image[x + 1, y]) shl 6) or
												   (pixelValue(image[x + 2, y]) shl 5) or
												   (pixelValue(image[x + 3, y]) shl 4) or
												   (pixelValue(image[x + 4, y]) shl 3) or
												   (pixelValue(image[x + 5, y]) shl 2) or
												   (pixelValue(image[x + 6, y]) shl 1) or
												   pixelValue(image[x + 7, y])
						
										spriteData[y * 3 + x / 8] = byte.toByte()
									}
								}
						
								FileOutputStream(toFile).use { it.write(spriteData) }
							}
						
							private fun pixelValue(color: Color): Int {
								return if (color != Color(0, 0, 0, 255)) 1 else 0
							}
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) In this implementation, the `pixelValue` private method checks if a pixel color is transparent or set, and returns the corresponding value (0 or 1). This method is used when constructing the byte value for each group of 8 pixels. The size of the `spriteData` byte array has been increased to 64 bytes, with the last byte remaining as 0 (default value).

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) implement unit tests for this class using Kotest and behavior spec						
						
						--

						![GPT](img/gpt-ava.svg) To implement unit tests for the `C64SpriteWriter` class using Kotest and behavior spec, you'll need to add the Kotest dependencies to your project, create a test class, and define tests using the behavior spec style. Here's an example:

						1. Add the Kotest dependencies to your `build.gradle.kts` file:
						
						```kotlin
						dependencies {
							// ...
							testImplementation("io.kotest:kotest-framework-api:4.6.3")
							testImplementation("io.kotest:kotest-assertions-core:4.6.3")
							testImplementation("io.kotest:kotest-runner-junit5:4.6.3")
						}
						```
						
						--

						![GPT](img/gpt-ava.svg) 2. Create a test class for the `C64SpriteWriter` and define tests using behavior spec:
						
						```kotlin
						import com.github.c64lib.rbt.processors.image.domain.Color
						import com.github.c64lib.rbt.processors.image.domain.Image
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.shouldBe
						import java.io.File
						import java.nio.file.Files
						
						class C64SpriteWriterTest : BehaviorSpec({
						
							fun createTestImage(): Image {
								val image = Image(24, 21)
						
								// Draw some example pixels
								image[0, 0] = Color(255, 255, 255, 255)
								image[7, 0] = Color(255, 255, 255, 255)
								image[15, 20] = Color(255, 255, 255, 255)
						
								return image
							}
						
							fun readSpriteData(file: File): ByteArray {
								return Files.readAllBytes(file.toPath())
							}
						
							given("a C64SpriteWriter instance") {
								val writer = C64SpriteWriter()
						
								`when`("writing a valid image to a file") {
									val image = createTestImage()
									val outputFile = File.createTempFile("sprite_", ".bin")
									outputFile.deleteOnExit()
						
									writer.write(image, outputFile)
						
									then("the resulting file should have the correct size and data") {
										val spriteData = readSpriteData(outputFile)
						
										spriteData.size shouldBe 64
										spriteData[0] shouldBe 0b10000001.toByte()
										spriteData[62] shouldBe 0b00100000.toByte()
										spriteData[63] shouldBe 0
									}
								}
							}
						})
						```
						
						--

						![GPT](img/gpt-ava.svg) In this example, the `C64SpriteWriterTest` class defines a behavior spec with a `given` block for the `C64SpriteWriter` instance. The `createTestImage()` function creates a test image, and the `readSpriteData()` function reads the sprite data from a file.
						
						The test scenario writes a valid image to a file using the `C64SpriteWriter` and checks whether the resulting file has the correct size (64 bytes) and data. The `outputFile` is a temporary file that is automatically deleted when the JVM exits.

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) this fails spriteData[62] shouldBe 0b00100000.toByte(), gets 0 instead of 32					
						
						--

						![GPT](img/gpt-ava.svg) Apologies for the oversight. Let's adjust the test setup to ensure the correct result is being tested. Update the `createTestImage()` function to set a pixel in the last byte of the sprite data:

						```kotlin
						fun createTestImage(): Image {
							val image = Image(24, 21)
						
							// Draw some example pixels
							image[0, 0] = Color(255, 255, 255, 255)
							image[7, 0] = Color(255, 255, 255, 255)
							image[7, 20] = Color(255, 255, 255, 255) // Set a pixel in the last byte of the sprite data
						
							return image
						}
						```
						
						Now, the test should pass as expected:
						
						```kotlin
						spriteData[62] shouldBe 0b00100000.toByte() // 32
						```

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) [it didn't, this is the second time I had to react manually; indexing was messed up, likely because I originally didn't mention I want 64 bytes instead of 63]

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) Implement another adapter, for this port:

						```kotlin
						interface WriteCharsetPort {
						  fun write(image: Image, toFile: File)
						}
						```
						
						that will write image data into a binary file encoded as bitmap mode of commodore 64 is encoded, that a 8 consenutive bytes define a 8x8 pixel block. Assume hires mode and restrict sensible dimensions of the source image						
						
						--

						![GPT](img/gpt-ava.svg) To implement the `WriteCharsetPort` interface, you need to create a class that writes the image data to a binary file encoded in the Commodore 64 bitmap mode. In this case, the bitmap mode is hires, and the image dimensions must be restricted to sensible values. 
						
						--

						![GPT](img/gpt-ava.svg) Here's a possible implementation:

						```kotlin
						import com.github.c64lib.rbt.processors.image.domain.Color
						import com.github.c64lib.rbt.processors.image.domain.Image
						import java.io.File
						import java.io.FileOutputStream
						
						class C64CharsetWriter : WriteCharsetPort {
							override fun write(image: Image, toFile: File) {
								require(image.width % 8 == 0) { "Image width must be a multiple of 8 for Commodore 64 hires charset" }
								require(image.height % 8 == 0) { "Image height must be a multiple of 8 for Commodore 64 hires charset" }
						
								val numBlocksX = image.width / 8
								val numBlocksY = image.height / 8
								val dataSize = numBlocksX * numBlocksY * 8
								val charsetData = ByteArray(dataSize)
						
								for (blockY in 0 until numBlocksY) {
									for (blockX in 0 until numBlocksX) {
										for (y in 0 until 8) {
											val yOffset = (blockY * 8 + y) * numBlocksX * 8
											val xOffset = blockX * 8
						
											val byte = (pixelValue(image[xOffset, yOffset + y]) shl 7) or
													   (pixelValue(image[xOffset + 1, yOffset + y]) shl 6) or
													   (pixelValue(image[xOffset + 2, yOffset + y]) shl 5) or
													   (pixelValue(image[xOffset + 3, yOffset + y]) shl 4) or
													   (pixelValue(image[xOffset + 4, yOffset + y]) shl 3) or
													   (pixelValue(image[xOffset + 5, yOffset + y]) shl 2) or
													   (pixelValue(image[xOffset + 6, yOffset + y]) shl 1) or
													   pixelValue(image[xOffset + 7, yOffset + y])
						
											charsetData[blockY * numBlocksX * 8 + blockX * 8 + y] = byte.toByte()
										}
									}
								}
						
								FileOutputStream(toFile).use { it.write(charsetData) }
							}
						
							private fun pixelValue(color: Color): Int {
								return if (color != Color(0, 0, 0, 255)) 1 else 

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) finish please						
						
						--

						![GPT](img/gpt-ava.svg) 
						```kotlin
								0
							}
						}
						```
				
						--

						![GPT](img/gpt-ava.svg) Here's the completed `C64CharsetWriter` class. The `write` method takes an `Image` and a `File` as input and writes the image data to the file in the Commodore 64 hires charset format. The method first checks if the image dimensions are valid, calculates the number of blocks in the x and y dimensions, and initializes the `charsetData` byte array. It then iterates through the image blocks and creates the charset data by converting the pixel values from the input image to the corresponding hires charset format. Finally, the method writes the resulting charset data to the specified file.

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) implement unit test in kotest using behavior spec						
						
						--

						![GPT](img/gpt-ava.svg) To implement a unit test for the `C64CharsetWriter` class using Kotest and behavior spec, create a test class and define tests using the behavior spec style. Here's an example:

						```kotlin
						import com.github.c64lib.rbt.processors.image.domain.Color
						import com.github.c64lib.rbt.processors.image.domain.Image
						import io.kotest.core.spec.style.BehaviorSpec
						import io.kotest.matchers.shouldBe
						import java.io.File
						import java.nio.file.Files
						
						class C64CharsetWriterTest : BehaviorSpec({
						
							fun createTestImage(): Image {
								val image = Image(16, 8)
						
								// Draw some example pixels
								image[0, 0] = Color(255, 255, 255, 255)
								image[7, 0] = Color(255, 255, 255, 255)
								image[15, 7] = Color(255, 255, 255, 255)
						
								return image
							}
						
							fun readCharsetData(file: File): ByteArray {
								return Files.readAllBytes(file.toPath())
							}
						
							given("a C64CharsetWriter instance") {
								val writer = C64CharsetWriter()
						
								`when`("writing a valid image to a file") {
									val image = createTestImage()
									val outputFile = File.createTempFile("charset_", ".bin")
									outputFile.deleteOnExit()
						
									writer.write(image, outputFile)
						
									then("the resulting file should have the correct size and data") {
										val charsetData = readCharsetData(outputFile)
						
										charsetData.size shouldBe 16
										charsetData[0] shouldBe 

						--
						<!-- .slide: data-background-gradient="radial-gradient(#283b95, #17b2c3)"-->

						![Hum](img/hum-ava.png) continue						
						
						--
						
						![GPT](img/gpt-ava.svg) 
						```kotlin
										0b10000001.toByte()
										charsetData[7] shouldBe 0b01000000.toByte()
										charsetData[15] shouldBe 0b00000001.toByte()
									}
								}
							}
						})
						```
		
						--
						
						![GPT](img/gpt-ava.svg) In this example, the `C64CharsetWriterTest` class defines a behavior spec with a `given` block for the `C64CharsetWriter` instance. The `createTestImage()` function creates a test image, and the `readCharsetData()` function reads the charset data from a file.
		
						The test scenario writes a valid image to a file using the `C64CharsetWriter` and checks whether the resulting file has the correct size (16 bytes) and data. The `outputFile` is a temporary file that is automatically deleted when the JVM exits.
						---

						<!-- .slide: data-background-image="img/ricky-speaks.jpg" data-background-opacity="0.2"-->
						### Conclusions

						* With well structured, modularized systems, it eliminates 95% of coding already.
						* Conversation memory saves a lot of time in specifying.
						* Big, messy, tangled systems - still a challenge.
						* No doubt, AI will be able to refactor such elephants into maintainable systems really soon.
						* GPT-4 fails for esoteric cases (i.e. for not so well documented and used libraries and so on).

						--

						#### GPT-3.5, GPT-4 - useful use cases

						* Replacement for Googling
						* Replacement for StackOverflow
						* Generate code from textual description
						* Explain existing code
						* Refactor existing code
						* Write tests for existing code
						* Migrate from one language to another
						* Migrate tech stack
						* ...

						--

						### Links

						* https://chat.openai.com/
						* https://huggingface.co/models
						* https://huggingface.co/orel12/ggml-gpt4all-j-v1.3-groovy
						* https://github.com/nomic-ai/gpt4all
						* https://www.deepl.com/translator
						* https://www.deepl.com/writegit
						* https://github.com/features/copilot

						--

						### These slides

						![QR](img/qr-code-slides.png)

						https://maciejmalecki.github.io/gpt-4-demo/

						--

						### The code (on prod)

						![QR](img/qr-code-commit.png)

						[link](https://github.com/c64lib/gradle-retro-assembler-plugin/commit/e242f75ae6d459fd15b26890f0bba7f7c7095e48)

						--

						<!-- .slide: data-background-image="img/ricky.jpg" data-background-opacity="0.5"-->

						### Should I be worried: Q&A

						* How would AI change my work (live)?
						* When would that happen?
						* Is my workplace safe?

						[img source](https://www.ranker.com/list/best-ricky-quotes-trailer-park-boys/movie-and-tv-quotes)
					</script>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				width: 1000,
				hash: true,
				slideNumber: 'c/t',
				mathjax2: {
					config: 'TeX-AMS_HTML-full',
					TeX: {
						Macros: {
							R: '\\mathbb{R}',
							set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
						}
					}
				},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>
